'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var minimist = _interopDefault(require('minimist'));
var deepExtend = _interopDefault(require('deep-extend'));
var path = _interopDefault(require('path'));
var fs = _interopDefault(require('fs'));
var ini = require('ini');
var yaml = require('yaml-js');
var stripJsonComments = _interopDefault(require('strip-json-comments'));
var flatnest = require('flatnest');

function keysToLowerCase(obj) {
  const newObj = {};
  Object.keys(obj).forEach(key => {
    newObj[key.toLowerCase()] = obj[key];
  });
  return newObj;
}
function normalize(obj = {}) {
  return flatnest.nest(keysToLowerCase(flatnest.flatten(obj)));
}
function parse(content) {
  try {
    return normalize(JSON.parse(stripJsonComments(content)));
  } catch (normalizeErr) {
    try {
      const yamlValue = yaml.load(content);

      if (typeof yamlValue === 'string') {
        throw new Error('Accidentally parsed ini as yaml :/');
      }

      return normalize(yamlValue);
    } catch (yamlErr) {
      return normalize(ini.parse(content));
    }
  }
}
function file(filePath) {
  try {
    return fs.readFileSync(filePath, 'utf-8');
  } catch (err) {
    return null;
  }
}
function find(...args) {
  const rel = path.join.apply(null, [].slice.call(args));

  function findRel(start, relativePath) {
    const filePath = path.join(start, relativePath);

    if (fs.existsSync(filePath)) {
      return filePath;
    }

    if (path.dirname(start) !== start) {
      return findRel(path.dirname(start), relativePath);
    }

    return null;
  }

  return findRel(process.cwd(), rel);
}
function conditionalTransformKeys(obj, condition, transform) {
  const newObj = {};
  Object.keys(obj).forEach(key => {
    const value = obj[key];

    if (condition === true || condition(key, value)) {
      newObj[transform(key, value)] = value;
    }
  });
  return newObj;
}
function env(prefix, envVars = process.env) {
  const normalizedPrefix = prefix.toUpperCase().replace(/[^A-Z0-9]+/g, '_');
  const vars = conditionalTransformKeys(envVars, key => key.indexOf(normalizedPrefix) === 0, key => key.substring(normalizedPrefix.length).replace(/[_]+/g, '.'));
  return normalize(vars);
}
function argv(args) {
  const {
    _: preservedUnderscore
  } = args;
  const vars = conditionalTransformKeys(args, key => key !== '_', key => key.replace(/[^a-z0-9]+/gi, '.'));
  vars._ = preservedUnderscore;
  return normalize(vars);
}

const isWin = process.platform === 'win32';
const etc = '/etc';
const home = isWin ? process.env.USERPROFILE : process.env.HOME;

function removeDuplicates(item, index, list) {
  return item && list.indexOf(item) === index;
}

function tupleify(item) {
  return [item, null];
}

function detupleify(index) {
  return tuple => tuple[index];
}

function removeFalsy(tuple) {
  return !!tuple[1];
}

function loadConfig(tuple) {
  const [filePath] = tuple;
  const content = file(filePath);

  if (content) {
    return [filePath, parse(content)];
  }

  return tuple;
}

function rucola(name, defaultArgs = {}, aliases = {}, customArgv) {
  if (typeof name !== 'string') {
    throw new Error('name argument must be a string');
  }

  const defaults = typeof defaultArgs === 'string' ? parse(defaultArgs) : defaultArgs;
  const argv$$1 = argv(customArgv || minimist([].concat(process.argv).splice(2), {
    alias: aliases
  }), aliases);
  const env$$1 = env(`${name}_`);
  const allConfigFiles = [!isWin && path.join(etc, name, 'config'), !isWin && path.join(etc, `${name}rc`), !isWin && path.join(etc, 'xdg', name, `${name}.rc`), home && path.join(home, '.config', name, 'config'), home && path.join(home, '.config', name), home && path.join(home, `.${name}`, 'config'), home && path.join(home, `.${name}rc`), find(`.${name}rc`), argv$$1.config].filter(removeDuplicates);
  const configTuples = allConfigFiles.map(tupleify).map(loadConfig).filter(removeFalsy);
  const usedConfigFiles = configTuples.map(detupleify(0));
  const configValues = configTuples.map(detupleify(1));
  const conf = deepExtend(...[normalize(defaults)].concat(configValues, env$$1, argv$$1));
  Object.defineProperty(conf, 'usedConfigs', {
    enumerable: false,
    writable: false,
    value: usedConfigFiles
  });
  Object.defineProperty(conf, 'checkedConfigs', {
    enumerable: false,
    writable: false,
    value: allConfigFiles
  });
  Object.defineProperty(conf, 'get', {
    enumerable: false,
    value: flatnest.seek.bind(null, conf)
  });
  return conf;
}

module.exports = rucola;
